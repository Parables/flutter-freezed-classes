type Query {
  users(
    # Limits number of fetched elements.
    first: Int = 10

    # The offset from which elements are returned.
    page: Int
  ): UserPaginator
  user(id: ID): User
  book(id: ID!): Book
  books(input: SearchBookInput): [Book!]!
  course(id: ID!): Course
  courses(title: String): [Course!]!
  programme(id: ID!): Programme
  programmes: [Programme!]
  programmeOutline(id: ID!): ProgrammeOutline
  programmeOutlines(programme: ID): [ProgrammeOutline!]
  profile(id: ID!): Profile
  profiles: [Profile!]
  contact(id: ID!): Contact
  contacts: [Contact!]
  contactInfo(profileID: ID!): ContactInfo
  lecturer(id: ID!): Lecturer
  lecturers: [Lecturer!]
  student(id: ID!): Student
  students: [Student!]
  enrollment(id: ID!): Enrollment
  enrollments: [Enrollment!]!
  fee(id: ID!): Fee
  fees: [Fee]
  paymentRecord(id: ID!): PaymentRecord
  paymentRecords(paidBy: ID): [PaymentRecord!]
  selectOption(id: ID!): SelectOption
  selectOptions(fieldName: String!, parentID: ID): [SelectOption!]
  childrenSelectOptions(id: ID): [SelectOption!]
}

# A paginated list of User items.
type UserPaginator {
  # Pagination information about the list of items.
  paginatorInfo: PaginatorInfo!

  # A list of User items.
  data: [User!]!
}

# Pagination information about the corresponding list of items.
type PaginatorInfo {
  # Total count of available items in the page.
  count: Int!

  # Current pagination page.
  currentPage: Int!

  # Index of first item in the current page.
  firstItem: Int

  # If collection has more pages.
  hasMorePages: Boolean!

  # Index of last item in the current page.
  lastItem: Int

  # Last page number of the collection.
  lastPage: Int!

  # Number of items per page in the collection.
  perPage: Int!

  # Total items available in the collection.
  total: Int!
}

type User {
  id: ID!
  name: String!
  email: String!
  created_at: DateTime!
  updated_at: DateTime!
}

# A datetime string with format `Y-m-d H:i:s`, e.g. `2018-05-23 13:43:32`.
scalar DateTime

type Book {
  id: ID!
  cover: String
  title: String!
  bookCode: String
  author: String
  inStock: Int!
  courses: [Course!]
  created_at: DateTime!
  updated_at: DateTime!
}

type Course {
  id: ID!
  title: String!
  courseCode: String
  creditHours: Int
  books: [Book!]
  created_at: DateTime!
  updated_at: DateTime!
}

input SearchBookInput {
  id: ID
  title: String
  bookCode: String
  author: String
  inStock: Int
}

type Programme {
  id: ID!
  title: String!
  programmeCode: String
  startLevel: Int!
  endLevel: Int!
  fees(level: Int): [Fee!]
  programmeOutlines(level: Int, semester: Int): [ProgrammeOutline!]
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
}

type Fee {
  id: ID!
  feeType: SelectOption!
  description: String
  amountPayable: Float!
  paymentCycle: SelectOption!
  paymentMethod: SelectOption!
  created_at: DateTime!
  updated_at: DateTime!
}

type SelectOption {
  id: ID!
  fieldName: String!
  parentID: ID
  name: String
  label: String
  value: String!
  created_at: DateTime!
  updated_at: DateTime!
}

type ProgrammeOutline {
  id: ID!
  programme: Programme!
  course: Course!
  level: Int!
  semester: SelectOption
  elective: Boolean
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
}

type Profile {
  id: ID!
  profileType: SelectOption!
  picture: String
  title: String
  fullName: String!
  lastName: String
  firstName: String
  middleName: String
  maidenName: String
  otherNames: String
  nickname: String
  prefix: String
  suffix: String
  dob: Date
  gender: Gender
  maritalStatus: SelectOption
  contactInfo: ContactInfo
  contacts: [Contact]
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
}

# A date string with format `Y-m-d`, e.g. `2011-05-23`.
scalar Date

enum Gender {
  FEMALE
  MALE
}

type ContactInfo {
  phone: [ContactTypeInfo]
  email: [ContactTypeInfo]
  address: [ContactTypeInfo]
  social_media: [ContactTypeInfo]
  website: [ContactTypeInfo]
  others: [ContactTypeInfo]
}

type ContactTypeInfo {
  value: String!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
}

type Contact {
  profile: Profile
  contactType: SelectOption!
  contactValue: String!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
}

type Lecturer {
  id: ID!
  profile: Profile!
  courses: [Course!]
  created_at: DateTime!
  updated_at: DateTime!
}

type Student {
  id: ID!
  applicationID: String!
  examsNumber: String!
  profile: Profile!
  academicYear: String!
  programme: Programme!
  startLevel: Int!
  currentLevel: Int!
  endLevel: Int!
  paymentRecords: [PaymentRecord!]
  enrollments: [Enrollment!]
  remarks: String
  admissionStatus: SelectOption
  admitted_on: DateTime!
  completed_on: DateTime
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
}

type PaymentRecord {
  id: ID!
  receiptImageUrl: String
  transactionDate: DateTime!
  transactionID: String!
  bank: SelectOption!
  amountPaid: Float!
  paidBy: Student!
  level: Int!
  semesterType: SelectOption!
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
}

type Enrollment {
  id: ID!
  student: Student!
  semester: SelectOption!
  level: Int!
  course: Course!
  booksGiven: [Book!]
  enrollmentStatus: SelectOption!
  remarks: String
  enrolled_on: DateTime!
  completed_on: DateTime
  created_at: DateTime!
  updated_at: DateTime!
  deleted_at: DateTime
}

type Mutation {
  createUser(name: String): User
  createBook(input: CreateBookInput!): Book
  updateBook(input: UpdateBookInput!): Book
  upsertBook(input: UpsertBookInput!): Book
  deleteBook(id: ID!): Book
  createCourse(input: CourseCreateInput!): Course
  updateCourse(input: CourseUpdateInput!): Course
  upsertCourse(input: CourseUpsertInput!): Course
  deleteCourse(id: ID!): Course
  createProgramme(input: CreateProgrammeInput!): Programme
  updateProgramme(input: UpdateProgrammeInput!): Programme
  upsertProgramme(input: UpsertProgrammeInput!): Programme
  deleteProgramme(id: ID!): Programme
  createProgrammeOutline(input: CreateProgrammeOutlineInput!): ProgrammeOutline
  updateProgrammeOutline(input: UpdateProgrammeOutlineInput!): ProgrammeOutline
  upsertProgrammeOutline(input: UpsertProgrammeOutlineInput!): ProgrammeOutline
  deleteProgrammeOutline(id: ID!): ProgrammeOutline
  createProfile(input: CreateProfileInput!): Profile
  updateProfile(input: UpdateProfileInput!): Profile
  upsertProfile(input: UpsertProfileInput!): Profile
  deleteProfile(id: ID!): Profile
  createContact(input: CreateContactInput!): Contact
  updateContact(input: UpdateContactInput!): Contact
  upsertContact(input: UpsertContactInput!): Contact
  deleteContact(id: ID!): Contact
  createLecturer(input: LecturerInput!): Lecturer
  updateLecturer(input: LecturerInput!): Lecturer
  upsertLecturer(input: LecturerInput!): Lecturer
  deleteLecturer(id: ID!): Lecturer
  createStudent(input: CreateStudentInput!): Student
  updateStudent(input: UpdateStudentInput!): Student
  upsertStudent(input: UpsertStudentInput!): Student
  deleteStudent(id: ID!): Student
  createEnrollment(input: CreateEnrollmentInput!): Enrollment
  updateEnrollment(input: UpdateEnrollmentInput!): Enrollment
  upsertEnrollment(input: UpsertEnrollmentInput!): Enrollment
  deleteEnrollment(id: ID!): Enrollment
  createFee(input: CreateFeeInput!): Fee
  updateFee(input: UpdateFeeInput!): Fee
  upsertFee(input: UpsertFeeInput!): Fee
  deleteFee(id: ID!): Fee
  createPaymentRecord(input: PaymentRecordCreateInput!): PaymentRecord
  updatePaymentRecord(input: PaymentRecordUpdateInput!): PaymentRecord
  upsertPaymentRecord(input: PaymentRecordUpsertInput!): PaymentRecord
  deletePaymentRecord(id: ID!): PaymentRecord
  createSelectOption(input: CreateSelectOptionInput!): SelectOption
  updateSelectOption(input: UpdateSelectOptionInput!): SelectOption
  upsertSelectOption(input: CreateSelectOptionInput!): SelectOption
  deleteSelectOption(id: ID!): SelectOption
}

input CreateBookInput {
  title: String!
  cover: String
  bookCode: String
  author: String
  inStock: Int
  courses: CoursesOperation
}

input CoursesOperation {
  create: [CourseCreateInput!]
  connect: [ID!]
  update: [CourseUpdateInput!]
  upsert: [CourseUpsertInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  disconnect: [ID!]
}

input CourseCreateInput {
  title: String!
  courseCode: String
  creditHours: Int
  books: BooksOperation
}

input BooksOperation {
  create: [CreateBookInput!]
  connect: [ID!]
  update: [UpdateBookInput!]
  upsert: [UpsertBookInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  disconnect: [ID!]
}

input UpdateBookInput {
  id: ID!
  title: String
  cover: String
  bookCode: String
  author: String
  inStock: Int
  courses: CoursesOperation
}

input UpsertBookInput {
  id: ID!
  title: String!
  cover: String
  bookCode: String
  author: String
  inStock: Int
  courses: CoursesOperation
}

input CourseUpdateInput {
  id: ID!
  title: String
  courseCode: String
  creditHours: Int
  books: BooksOperation
}

input CourseUpsertInput {
  id: ID!
  title: String!
  courseCode: String
  creditHours: Int
  books: BooksOperation
}

input CreateProgrammeInput {
  title: String!
  programmeCode: String
  startLevel: Int!
  endLevel: Int!
  fees: FeesOperation
  programmeOutlines: ProgrammeOutlinesOperation
}

input FeesOperation {
  create: [CreateFeeInput!]
  connect: [ID!]
  update: [UpdateFeeInput!]
  upsert: [UpsertFeeInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  disconnect: [ID!]
}

input CreateFeeInput {
  feeType: SelectOptionOperation!
  description: String
  amountPayable: Float!
  paymentCycle: SelectOptionOperation!
  paymentMethod: SelectOptionOperation!
}

input SelectOptionOperation {
  create: CreateSelectOptionInput
  connect: ID
  update: UpdateSelectOptionInput
  upsert: UpsertSelectOptionInput
}

input CreateSelectOptionInput {
  fieldName: String!
  parentID: ID
  name: String
  label: String
  value: String!
}

input UpdateSelectOptionInput {
  id: ID!
  fieldName: String
  parentID: ID
  name: String
  label: String
  value: String
}

input UpsertSelectOptionInput {
  fieldName: String!
  parentID: ID
  name: String
  label: String
  value: String!
}

input UpdateFeeInput {
  id: ID!
  feeType: SelectOptionOperation!
  description: String
  amountPayable: Float
  paymentCycle: SelectOptionOperation
  paymentMethod: SelectOptionOperation
}

input UpsertFeeInput {
  id: ID!
  feeType: SelectOptionOperation!
  description: String
  amountPayable: Float!
  paymentCycle: SelectOptionOperation!
  paymentMethod: SelectOptionOperation!
}

input ProgrammeOutlinesOperation {
  create: [CreateProgrammeOutlinesInput!]
  connect: [ID!]
  update: [UpdateProgrammeOutlinesInput!]
  upsert: [UpsertProgrammeOutlinesInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  disconnect: [ID!]
}

input CreateProgrammeOutlinesInput {
  course: CourseOperation!
  level: Int!
  semester: SelectOptionOperation
  elective: Boolean
}

input CourseOperation {
  create: CourseCreateInput
  connect: ID
  update: CourseUpdateInput
  upsert: CourseUpsertInput
}

input UpdateProgrammeOutlinesInput {
  id: ID!
  course: CourseOperation
  level: Int
  semester: SelectOptionOperation
  elective: Boolean
}

input UpsertProgrammeOutlinesInput {
  id: ID!
  course: CourseOperation!
  level: Int!
  semester: SelectOptionOperation
  elective: Boolean
}

input UpdateProgrammeInput {
  id: ID!
  title: String
  programmeCode: String
  startLevel: Int
  endLevel: Int
  fees: FeesOperation
  programmeOutlines: ProgrammeOutlinesOperation
}

input UpsertProgrammeInput {
  id: ID!
  title: String!
  programmeCode: String
  startLevel: Int!
  endLevel: Int!
  fees: FeesOperation
  programmeOutlines: ProgrammeOutlinesOperation
}

input CreateProgrammeOutlineInput {
  programme: ProgrammeOperation!
  course: CourseOperation!
  level: Int!
  semester: SelectOptionOperation
  elective: Boolean
}

input ProgrammeOperation {
  create: CreateProgrammeInput
  connect: ID
  update: UpdateProgrammeInput
  upsert: UpsertProgrammeInput
}

input UpdateProgrammeOutlineInput {
  id: ID!
  programme: ProgrammeOperation
  course: CourseOperation
  level: Int
  semester: SelectOptionOperation
  elective: Boolean
}

input UpsertProgrammeOutlineInput {
  id: ID!
  programme: ProgrammeOperation!
  course: CourseOperation!
  level: Int!
  semester: SelectOptionOperation
  elective: Boolean
}

input CreateProfileInput {
  profileType: SelectOptionOperation!
  picture: String
  title: String
  fullName: String!
  lastName: String
  firstName: String
  middleName: String
  maidenName: String
  otherNames: String
  nickname: String
  prefix: String
  suffix: String
  dob: Date
  gender: Gender
  maritalStatus: SelectOptionOperation
  contacts: ProfileContactsOperation
}

input ProfileContactsOperation {
  create: [CreateProfileContactInput!]
  connect: [ID!]
  update: [UpdateProfileContactInput!]
  upsert: [UpsertProfileContactInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  disconnect: [ID!]
}

input CreateProfileContactInput {
  contactType: SelectOptionOperation!
  contactValue: String!
}

input UpdateProfileContactInput {
  id: ID!
  contactType: SelectOptionOperation
  contactValue: String
}

input UpsertProfileContactInput {
  id: ID!
  contactType: SelectOptionOperation!
  contactValue: String!
}

input UpdateProfileInput {
  id: ID!
  profileType: SelectOptionOperation
  picture: String
  title: String
  fullName: String
  lastName: String
  firstName: String
  middleName: String
  maidenName: String
  otherNames: String
  nickname: String
  prefix: String
  suffix: String
  dob: Date
  gender: Gender
  maritalStatus: SelectOptionOperation
  contacts: ProfileContactsOperation
}

input UpsertProfileInput {
  id: ID!
  profileType: SelectOptionOperation!
  picture: String
  title: String
  fullName: String!
  lastName: String
  firstName: String
  middleName: String
  maidenName: String
  otherNames: String
  nickname: String
  prefix: String
  suffix: String
  dob: Date
  gender: Gender
  maritalStatus: SelectOptionOperation
  contacts: ProfileContactsOperation
}

input CreateContactInput {
  profile: ProfileOperation!
  contactType: SelectOptionOperation!
  contactValue: String!
}

input ProfileOperation {
  create: CreateProfileInput
  connect: ID
  update: UpdateProfileInput
  upsert: UpsertProfileInput
}

input UpdateContactInput {
  id: ID!
  profile: ProfileOperation
  contactType: SelectOptionOperation
  contactValue: String
}

input UpsertContactInput {
  id: ID!
  profile: ProfileOperation!
  contactType: SelectOptionOperation!
  contactValue: String!
}

input LecturerInput {
  id: ID
  profile: ProfileOperation
  courses: [CoursesOperation]
}

input CreateStudentInput {
  applicationID: String!
  examsNumber: String!
  profile: ProfileOperation!
  academicYear: String!
  programme: ProgrammeOperation!
  startLevel: Int!
  currentLevel: Int!
  endLevel: Int!
  paymentRecords: PaymentRecordsOperation
  enrollments: StudentEnrollmentsOperation
  remarks: String
  admissionStatus: SelectOptionOperation
  admitted_on: DateTime!
  completed_on: DateTime
}

input PaymentRecordsOperation {
  create: [PaymentRecordCreateInput!]
  connect: [ID!]
  update: [PaymentRecordUpdateInput!]
  upsert: [PaymentRecordUpsertInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  disconnect: [ID!]
}

input PaymentRecordCreateInput {
  receiptImageUrl: String
  transactionDate: DateTime!
  transactionID: String!
  bank: SelectOptionsOperation!
  amountPaid: Float!
  paidBy: StudentOperation!
  level: Int!
  semesterType: SelectOptionOperation!
}

input SelectOptionsOperation {
  create: [CreateSelectOptionInput!]
  connect: [ID]
  update: [UpdateSelectOptionInput!]
  upsert: [UpsertSelectOptionInput!]
  sync: [ID]
  syncWithoutDetaching: [ID]
  delete: [ID]
}

input StudentOperation {
  create: CreateStudentInput
  connect: ID
  update: UpdateStudentInput
  upsert: UpsertStudentInput
}

input UpdateStudentInput {
  id: ID!
  applicationID: String
  examsNumber: String
  profile: ProfileOperation
  academicYear: String
  programme: ProgrammeOperation
  startLevel: Int
  currentLevel: Int
  endLevel: Int
  paymentRecords: PaymentRecordsOperation
  enrollments: StudentEnrollmentsOperation
  remarks: String
  admissionStatus: SelectOptionOperation
  admitted_on: DateTime
  completed_on: DateTime
}

input StudentEnrollmentsOperation {
  create: [CreateStudentEnrollmentInput!]
  connect: [ID!]
  update: [UpdateStudentEnrollmentInput!]
  upsert: [UpsertStudentEnrollmentInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  disconnect: [ID!]
}

input CreateStudentEnrollmentInput {
  semester: SelectOptionOperation!
  level: Int!
  course: CourseOperation!
  booksGiven: BooksOperation
  enrollmentStatus: SelectOptionOperation!
  remarks: String
  enrolled_on: DateTime!
  completed_on: DateTime
}

input UpdateStudentEnrollmentInput {
  id: ID!
  semester: SelectOptionOperation
  level: Int
  course: CourseOperation
  booksGiven: BooksOperation
  enrollmentStatus: SelectOptionOperation
  remarks: String
  enrolled_on: DateTime
  completed_on: DateTime
}

input UpsertStudentEnrollmentInput {
  id: ID!
  semester: SelectOptionOperation!
  level: Int!
  course: CourseOperation!
  booksGiven: BooksOperation
  enrollmentStatus: SelectOptionOperation!
  remarks: String
  enrolled_on: DateTime!
  completed_on: DateTime
}

input UpsertStudentInput {
  id: ID!
  applicationID: String!
  examsNumber: String!
  profile: ProfileOperation!
  academicYear: String!
  programme: ProgrammeOperation!
  startLevel: Int!
  currentLevel: Int!
  endLevel: Int!
  paymentRecords: PaymentRecordsOperation
  enrollments: StudentEnrollmentsOperation
  remarks: String
  admissionStatus: SelectOptionOperation
  admitted_on: DateTime!
  completed_on: DateTime
}

input PaymentRecordUpdateInput {
  id: ID!
  receiptImageUrl: String
  transactionDate: DateTime
  transactionID: String
  bank: SelectOptionsOperation
  amountPaid: Float
  paidBy: StudentOperation
  level: Int
  semesterType: SelectOptionOperation
}

input PaymentRecordUpsertInput {
  id: ID!
  receiptImageUrl: String
  transactionDate: DateTime!
  transactionID: String
  bank: SelectOptionsOperation
  amountPaid: Float!
  paidBy: StudentOperation!
  level: Int!
  semesterType: SelectOptionOperation!
}

input CreateEnrollmentInput {
  student: StudentOperation!
  semester: SelectOptionOperation!
  level: Int!
  course: CourseOperation!
  booksGiven: BooksOperation
  enrollmentStatus: SelectOptionOperation!
  remarks: String
  enrolled_on: DateTime!
  completed_on: DateTime
}

input UpdateEnrollmentInput {
  id: ID!
  student: StudentOperation
  semester: SelectOptionOperation
  level: Int
  course: CourseOperation
  booksGiven: BooksOperation
  enrollmentStatus: SelectOptionOperation
  remarks: String
  enrolled_on: DateTime
  completed_on: DateTime
}

input UpsertEnrollmentInput {
  id: ID!
  student: StudentOperation!
  semester: SelectOptionOperation!
  level: Int!
  course: CourseOperation!
  booksGiven: BooksOperation
  enrollmentStatus: SelectOptionOperation!
  remarks: String
  enrolled_on: DateTime!
  completed_on: DateTime
}

input BookOperation {
  create: CreateBookInput
  connect: ID
  update: UpdateBookInput
  upsert: UpsertBookInput
}

input ProfilesOperation {
  create: [CreateProfileInput!]
  connect: [ID!]
  update: [UpdateProfileInput!]
  upsert: [UpsertProfileInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  disconnect: [ID!]
}

input ContactsOperation {
  create: [CreateContactInput!]
  connect: [ID!]
  update: [UpdateContactInput!]
  upsert: [UpsertContactInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  disconnect: [ID!]
}

input LecturerOperation {
  create: LecturerInput
  connect: ID
  update: LecturerInput
  upsert: LecturerInput
}

input LecturerOperations {
  create: [LecturerInput!]
  connect: ID
  update: [LecturerInput!]
  upsert: [LecturerInput!]
  sync: ID
  syncWithoutDetaching: ID
  delete: ID
}

input StudentsOperation {
  create: [CreateStudentInput!]
  connect: [ID!]
  update: [UpdateStudentInput!]
  upsert: [UpsertStudentInput!]
  sync: [ID!]
  syncWithoutDetaching: [ID!]
  disconnect: [ID!]
}

input FeeOperation {
  create: CreateFeeInput
  connect: ID
  update: UpdateFeeInput
  upsert: UpsertFeeInput
}

input PaymentRecordOperation {
  create: PaymentRecordCreateInput
  connect: ID
  update: PaymentRecordUpdateInput
  upsert: PaymentRecordUpsertInput
}

# Pagination information about the corresponding list of items.
type PageInfo {
  # When paginating forwards, are there more items?
  hasNextPage: Boolean!

  # When paginating backwards, are there more items?
  hasPreviousPage: Boolean!

  # When paginating backwards, the cursor to continue.
  startCursor: String

  # When paginating forwards, the cursor to continue.
  endCursor: String

  # Total number of node in connection.
  total: Int

  # Count of nodes in current request.
  count: Int

  # Current page of request.
  currentPage: Int

  # Last page in connection.
  lastPage: Int
}
